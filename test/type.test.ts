import { describe, expect, test } from 'vitest';
import { Registrie } from '../src/registrie';

import {
  BaseObject,
  EntryObject,
  EntryObjectWithChildren,
  EntryObjectWithInverseChildren,
  ArrayType,
  NumberType,
  BooleanType,
  AnyType,
  UndefinedType,
  NullType,
  FunctionType,
  mockBaseObject,
  mockEntryObject,
  mockEntryObjectWithChildren,
  mockEntryObjectWithInverseChildren,
  mockArrayType,
  mockNumberType,
  mockBooleanType,
  mockAnyType,
  mockUndefinedType,
  mockNullType,
  mockFunctionType
} from './mock-data';

// Because it is a written to test linting generated by ts displaying that errors in the IDE is expected
describe('Test linting types and registering objects types', () => {
  test('Any object with no params must pass', () => {
    const validBaseObject = Registrie<BaseObject>();
    expect(() =>
      validBaseObject.register('object', mockBaseObject)
    ).not.toThrow();
  });

  test('Object with key must pass if first arg is that key', () => {
    const validEntryObject = Registrie<EntryObject>('usage');
    expect(() => validEntryObject.register(mockEntryObject)).not.toThrow();
  });

  test('Object must fail if first arg key does not exist in object', () => {
    const invalidEntryObject = Registrie<EntryObject>('block');
    expect(() => invalidEntryObject.register(mockEntryObject)).toThrow();
  });

  test('Object with children must pass if there is a key in object for first arg and object type has a key for children', () => {
    const validEntryObjectWithChildren = Registrie<EntryObjectWithChildren>(
      'usage',
      'subCommands'
    );
    expect(() =>
      validEntryObjectWithChildren.register(mockEntryObjectWithChildren)
    ).not.toThrow();
  });

  test('Object with children must fail if children key does not exist in object', () => {
    const invalidEntryObjectWithChildren = Registrie<EntryObjectWithChildren>(
      'usage',
      'children'
    );
    expect(() =>
      invalidEntryObjectWithChildren.register(mockEntryObjectWithChildren)
    ).toThrow();
  });

  test('Object with children must fail if children key is not an array of objects', () => {
    const invalidEntryObjectWithChildren =
      Registrie<EntryObjectWithInverseChildren>('usage', 'subCommands');
    expect(() =>
      invalidEntryObjectWithChildren.register(
        mockEntryObjectWithInverseChildren
      )
    ).toThrow();
  });

  test('Array must pass if first arg is not set', () => {
    const validArrayType = Registrie<ArrayType>();
    expect(() => validArrayType.register('array', mockArrayType)).not.toThrow();
  });

  test('Array must fail if first arg is set', () => {
    const invalidArrayType = Registrie<ArrayType>('usage');
    expect(() => invalidArrayType.register(mockArrayType)).toThrow();
  });

  test('Number must pass if first arg is not set', () => {
    const validNumberType = Registrie<NumberType>();
    expect(() =>
      validNumberType.register('number', mockNumberType)
    ).not.toThrow();
  });

  test('Number must fail if first arg is set', () => {
    const invalidNumberType = Registrie<NumberType>('usage');
    expect(() => invalidNumberType.register(mockNumberType)).toThrow();
  });

  test('Boolean must pass if first arg is not set', () => {
    const validBooleanType = Registrie<BooleanType>();
    expect(() =>
      validBooleanType.register('boolean', mockBooleanType)
    ).not.toThrow();
  });

  test('Boolean must fail if first arg is set', () => {
    const invalidBooleanType = Registrie<BooleanType>('usage');
    expect(() => invalidBooleanType.register(mockBooleanType)).toThrow();
  });

  test('Any must pass if first arg is not set', () => {
    const validAnyType = Registrie<AnyType>();
    expect(() => validAnyType.register('any', mockAnyType)).not.toThrow();
  });

  test('Any must fail if first arg is set', () => {
    const invalidAnyType = Registrie<AnyType>('usage');
    expect(() => invalidAnyType.register(mockAnyType)).toThrow();
  });

  test('Undefined must pass if first arg is not set', () => {
    const validUndefinedType = Registrie<UndefinedType>();
    expect(() =>
      validUndefinedType.register('undefined', mockUndefinedType)
    ).not.toThrow();
  });

  test('Undefined must fail if first arg is set', () => {
    const invalidUndefinedType = Registrie<UndefinedType>('usage');
    expect(() => invalidUndefinedType.register(mockUndefinedType)).toThrow();
  });

  test('Null must pass if first arg is not set', () => {
    const validNullType = Registrie<NullType>();
    expect(() => validNullType.register('null', mockNullType)).not.toThrow();
  });

  test('Null must fail if first arg is set', () => {
    const invalidNullType = Registrie<NullType>('usage');
    expect(() => invalidNullType.register(mockNullType)).toThrow();
  });

  test('Function must pass if first arg is not set', () => {
    const validFunctionType = Registrie<FunctionType>();
    expect(() =>
      validFunctionType.register('function', mockFunctionType)
    ).not.toThrow();
  });

  test('Function must fail if first arg is set', () => {
    const invalidFunctionType = Registrie<FunctionType>('usage');
    expect(() => invalidFunctionType.register(mockFunctionType)).toThrow();
  });
});
